#region copyright
/*
 * This code is from the Lawo/ember-plus GitHub repository and is licensed with
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
 #endregion

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;

namespace EmberPlusProviderClassLib
{
    public class GlowListener : IDisposable
    {
        public GlowListener(int port, int maxPackageLength, Dispatcher dispatcher)
        {
            Port = port;
            MaxPackageLength = maxPackageLength;
            Dispatcher = dispatcher;

            _listener = new TcpListener(IPAddress.Any, port);
            _listener.Start();
            _listener.BeginAcceptSocket(AcceptCallback, _listener);

            dispatcher.GlowRootReady += Dispatcher_GlowRootReady;
        }

        public int Port { get; }
        public int MaxPackageLength { get; }
        public Dispatcher Dispatcher { get; }

        public void CloseClient(Client client)
        {
            lock (_sync)
                _clients.Remove(client);

            client.Dispose();
        }

        #region Implementation
        TcpListener _listener;
        readonly List<Client> _clients = new List<Client>();
        readonly byte[] _buffer = new byte[1024];
        readonly object _sync = new object();

        void AcceptCallback(IAsyncResult result)
        {
            var listener = (TcpListener)result.AsyncState;

            try
            {
                var socket = listener.EndAcceptSocket(result);
                var client = new Client(this, socket, MaxPackageLength, Dispatcher);

                lock (_sync)
                    _clients.Add(client);

                listener.BeginAcceptSocket(AcceptCallback, listener);
                socket.BeginReceive(_buffer, 0, _buffer.Length, SocketFlags.None, ReceiveCallback, client);
            }
            catch (SocketException ex)
            {
                Debug.WriteLine($"Exception: GlowListener/AcceptCallback/SocketException {ex.Message}");
            }
            catch (ObjectDisposedException ex)
            {
                Debug.WriteLine($"Exception: GlowListener/AcceptCallback/ObjectDisposedException {ex.Message}");
            }
        }

        void ReceiveCallback(IAsyncResult result)
        {
            var client = (Client)result.AsyncState;
            var socket = client.Socket;

            if (socket != null)
            {
                try
                {
                    var count = socket.EndReceive(result);

                    if (count > 0)
                    {
                        client.Read(_buffer, count);

                        socket.BeginReceive(_buffer, 0, _buffer.Length, SocketFlags.None, ReceiveCallback, client);
                    }
                    else
                    {
                        CloseClient(client);
                    }
                }
                catch (SocketException ex)
                {
                    Debug.WriteLine($"Exception: GlowListener/ReceiveCallback/SocketException {ex.Message}");
                    CloseClient(client);
                }
                catch (ObjectDisposedException ex)
                {
                    Debug.WriteLine($"Exception: GlowListener/ReceiveCallback/ObjectDisposedException {ex.Message}");
                }
            }
        }

        void Dispatcher_GlowRootReady(object sender, Dispatcher.GlowRootReadyArgs e)
        {
            try
            {
                lock (_sync)
                {
                    // INFO:
                    // This part is changed from original code. Original code had a
                    // foreach that caused an exception, because the list can change
                    // during enumeration.
                    for(int index = 0; index < _clients.Count; index++)
                    {
                        var client = _clients[index];
                        if (client != null && client != e.SourceClient)
                        {
                            try
                            {
                                if (e.Matrix == null || client.HasSubscribedToMatrix(e.Matrix))
                                    client.Write(e.Root);

                            }
                            catch (Exception ex)
                            {
                                Debug.Write(ex, $"Exception in Dispatcher_GlowRootReady when updating client. {client}");
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.Write(ex, "Exception in Dispatcher_GlowRootReady");
            }
        }
        #endregion

        #region IDisposable Members
        public void Dispose()
        {
            lock (_sync)
            {
                foreach (var client in _clients)
                    client.Dispose();

                _clients.Clear();

                if (_listener != null)
                {
                    _listener.Stop();
                    _listener = null;
                }
            }
        }
        #endregion
    }
}
